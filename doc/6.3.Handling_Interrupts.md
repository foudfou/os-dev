# 6.3 Handling Interrupts

Now we can print things on the screen, we'd like to start interacting with our
OS by typing things on the screen using a keyboard. From the CPU point of view,
this is getting *input* from the hardware.

The difficulty in achieving this goal is that we'll need to setup 3 things
before seeing any result: interrupts, the PIC and the keyboard. We'll start by
setting up the first two, and then verify our setup by issuing some exception
in our kernel's `main()` which should print its number on the screen. Later in
the next chapter we will look into implementing a minimal keyboard driver.

## 6.3.1 Interrupts

> The x86 architecture is an interrupt driven system. External events trigger
> an interrupt — the normal control flow is interrupted and an *Interrupt
> Service Routine* (ISR) is called. [^osdev]

Interrupts are an efficient way for the hardware to signal the CPU that some
intersting event has occured.

> An example of a hardware interrupt is the keyboard: every time you press a
> key, the keyboard triggers IRQ1 (Interrupt Request 1), and the corresponding
> interrupt handler is called. [^osdev]

There are 3 sources or types of interrupts [^dzyoba]:

- Hardware interrupts: comes from hardware devices like keyboard, the serial
  port or the timer.
- Software interrupts: generated by the software `int` instruction. Often used
  for system calls.
- Exceptions: generated by CPU itself in response to some error like "divide by
  zero" or "page fault".

In protected mode we can use up to 256 interrupts, the first 32 being reserved
for exceptions.

Interrupts are handled via the *Interrupt Descriptor Table* (IDT) in Protected
Mode, and the *Interrupt Vector Table* (IVT) in Real Mode. Similarily to the
GDT, we need to define a structure (idt size and idt address) and load it to
the IDTR CPU register with the special instruction `lidt`. Note the IDT will
make use of the GDT. Fortunately we have that covered already.

When defining an ISR in the IDT — in this context the ISR is also called a
*gate*, we need to specify its type, which is one of:

- Task handler: used by hardware x86 task management. Linux stopped using it
  for portability and efficiency [^so-tss].
- Interrupt handler: disables interrupts (CPU clears IF flag), ensuring no
  other interrupt is signaled until the handler returns.
- Trap handler: can disable interrupts manually as needed.

One caveat when implementing our handlers is that they must return with the
`iret` assembly code (`iretq` in long mode), instead of the usual `ret` or
`retf`. Which makes it slightly more difficult to implement everthing in C.

But before diving into the implementation, let's look a what the CPU does when
calling an interrupt handler:

1. The CPU pushes some registers to the stack:
   EFLAGS -> CS (2-bytes padded to form a doubleword) -> EIP
2. The CPU clears the interrupt flag (IF), unless the handler is trap gate. If
   the interrupt is an exception, the CPU pushes an error code onto the stack,
   as a doubleword.
3. The CPU loads the segment-selector value from the associated IDT descriptor
   into CS.

Basically the CPU switches the execution context.

Back to the handlers' implementation, we could be tempted to write them in C
using inline assembly:

    /* How NOT to write an interrupt handler */
    void interrupt_handler(void)
    {
        asm("pushad"); /* Save registers. */
        /* do something */
        asm("popad");  /* Restore registers. */
        asm("iret");   /* This will triple-fault! */
    }

Note this is one of the most well-known triple-fault errors. A triple-fault
error happens when: an exception occurs while handling an exception which
occured while handling a regular exception handler.

With the C function above, the compiler will mess things up, like adding stack
handling code before and after the function. This will mess up the stack at
execution because the assembly function will start by pushing EBP and return at
`iret` without popping it.

This leaves us with either writing our interrupt handlers in plain assembly or
writing an assembly wrapper that will:

1. save registers for example via `pushad` ("push all double")
2. call a generic C function which will do the real work
3. restore registers (`popad`)
3. do the `iret`

Note GCC proposes `__attribute__ ((interrupt))` which converts the function
into an interrupt handler. But the general advice is not to use it as the
handler receives an `interrupt_frame` structure which only contains the things
the CPU automatically pushes (EIP, CS, EFLAGS); where as a typical OS will want
access all saved registers.

The overall setup will look like this:

```
 CPU               idt.c                   isr.asm                   idt.c
+--------+        +-------------------+   +------------------+      +-------------------------------+
|        |        |                   |   |                  |      |                               |
|  IDTR -----------> idt              |   |  isr_stub_table  |      |                  isr_table    |
|        |        |                   |   |                  |      |                               |
|        |        |  idt_entry idt[0] -----> isr_stub_0 --+  |      |              +-> isr_table[0] |
+--------+        |                   |   |               |  |      |              |                |
                  |                   |   |               |  |  +---- isr_handler -+                |
                  |                   |   |               |  |  |   |                               |
                  |                   |   |  isr_stub_255 |  |  |   |                               |
                  |                   |   |               |  |  |   |                               |
                  |                   |   | +-------------+  |  |   |                               |
                  |                   |   | |                |  |   |                               |
                  |                   |   | +- isr_wrapper -----+   |                               |
                  |                   |   |                  |      |                               |
                  +-------------------+   +------------------+      +-------------------------------+
```

Ideally the IDT, which lives in memory, would directly point to the interrupt
handlers. But because of the wrapping of these handlers, we end up with a more
involved setup. The confusing aspect in my view is the back-and-forth between
assembly and C, where all assembly ISRs point to a single `isr_handler` which
acts as a dispatcher to the appropriate interrupt handler pointed by the
`isr_table`. We can then easily add specific handlers to the (second-level) ISR
table using `isr_register()`.

The machinery to wrap ISR calls is achieved in `isr.asm`, where we:
- define `isr_wrapper` to wrap the generic C `isr_handler()`.
- define the ISR entries using NASM macros. We can't avoid defining one stub
  per interrupt level as we want to pass the level to the handler.
- define 2 generic macros `isr_no_err_stub` and `isr_no_err_stub`, used
  to actually define the stubs, depending on if the interrupt generates an
  error or not.

```asm
%macro isr_err_stub 1
isr_stub_%+%1:
    ; the error code is already pushed to the stack
    push %1                    ; push interrupt number
    jmp isr_wrapper
%endmacro
```

Most of the time we want to disable interrupts (`cli`) while handling them. But
in order to keep our system reactive, we should try to return from our handling
function as soon as possible. The usual practice is thus to split our routine
into an uninterruptible *top-half*, which does the minimum to acknowledge the
information signaled by the interrupt, like saving the keyboard key code to
some ring buffer, and an interruptible *bottom-half* to do the actual work,
like mapping the key code to a character. For simplicity we will stick to
uninterruptible single-block handlers in this tutorial.


## 6.3.2 Interlude: linker script

When starting implementing our C kernel, we realized soon enough that compiling
it with gcc (11.2) [produces a huge binary
image](https://stackoverflow.com/questions/65037919/minimal-executable-size-now-10x-larger-after-linking-than-2-years-ago-for-tiny)
(129MB), which bochs seems to refuse for 1.44 MB floppy. The proper solution
would probably be to switch to multiboot altogether, or use any kind of already
available bootloader, and build a nicely partitionned filesystem image. Since
we wanted to concentrate on the kernel rather than the boot process, we came up
with configuring bochs to boot from disk:

```
# boschsrc
ata0-master: type=disk, mode=flat, path="os.img"
boot: disk
```

But when starting implementing keyboard interrupts, our kernel started crashing
inexplicably (`3rd (13) exception with no resolution, shutdown status is 00h,
resetting`). [An osdev forum
post](https://forum.osdev.org/viewtopic.php?p=115073&sid=b67fde41216a1f94109184d1d2d1701c#p115073)
finally made us realize we were loading too few sectors from the disk when
loading our kernel in `boot/boot_sect.asm`!

Using a linker script solved the issue and now produces a 5.5KB kernel.

> When developing user-space programs, your toolchain ships with default
> scripts for linking such programs. However, these are unsuitable for kernel
> development and you need to provide your own customized linker script.


## 6.3.3 Programmable Interrupt Controller (PIC)

Not to be confused with [PIC microcontroller](https://en.wikipedia.org/wiki/PIC_microcontroller).

To start using hardware interrupts we must first configure the PIC chips.

> The PIC is one of the most important chips making up the x86
> architecture. Without it, the x86 architecture would not be an interrupt
> driven architecture. [^osdev]

It takes the load of interruptions off the CPU and provides several benefits:

- Saves pins on CPU.
- Can handle many interrupt lines. PICs are usually arranged in cascade.
- Ability to mask a particular interrupt line instead of all (`cli`).
- Interrupts queueing.

Modern systems use APIC (Advanced Programmable Interrupt Controller),
especially those with multiple cores/processors.

> The APIC is an architectural design intended to solve interrupt routing in
> multiprocessor computer systems. It's a split architecture design, with a local
> component (LAPIC) usually integrated into the processor itself, and an optional
> I/O APIC on a system bus. [^w-apic]

APIC is still backwards compatible so for simplicity we're going to use the PIC
interface. For initialization, we'll need to do a couple of things.

> In protected mode, the IRQs 0 to 7 conflict with the CPU exception which are
> reserved by Intel up until 0x1F. (It was an IBM design mistake.) [^osdev]

So, when initializing the PIC, we need to tell it to remap interrupt
levels. For example, when IRQ1 is issued, the CPU needs to received as
IRQ33. The initialization sequence consists of:

- set both PICs' vector offsets (ICW2): PIC1 gets 32, PIC2 gets 40.
- tell PICs how they are wired (ICW3) as they're both link via specific pins.
- set additional configuration on how the PICs will operate (ICW4).

On IRQ reception, the CPU needs to acknowledge by sending both PICs an
end-of-interrupt (EOI) signal. IRQs can be enable or disabled using a bitmask.
Counterintuitively enough, setting a bit for an IRQ level in the mask actually
*disables* the corresponding IRQ!


## References

- [^osdev-notes]: [osdev-notes](https://github.com/dreamos82/Osdev-Notes/tree/master/PS2_Keyboard)
- [^littleosbook]: [littleosbook](https://github.com/littleosbook/littleosbook/blob/master/interrupts.md)
- [^osdev]: [osdev](https://wiki.osdev.org/)
- [^so-tss]: https://stackoverflow.com/a/2761422
- [^dzyoba]: [dzyoba](https://alex.dzyoba.com/blog/os-interrupts/)
- [^w-apic]: [Wikipedia APIC](https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller)
