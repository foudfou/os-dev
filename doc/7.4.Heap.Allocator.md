# 7.4 Heap Allocator

FIXME Hux got this wrong: OSTEP chap 17 *Free-Space Management* really is about

> a user-level memory-allocation library (as in malloc() and free()) and in an
> OS managing physical memory when using segmentation to implement virtual
> memory.

TODO adapt xv6 kalloc() and keep kheap aside for later umalloc.

To complete our memory management, we need a proper heap allocator, also
capable of freeing, that will thus provide `kalloc()` and `kfree()` to other
parts of the kernel, for example for filesystem inodes.

Our current allocator (`kalloc_temp()`) is only useful during the boot process
to allocate long-lived kernel structures. Also the kernel allocator is not to
be confused with the frame allocator (`frame_alloc()`), which only tracks
allocated frames.

For the implementation, we'll follow Hux [^hux-kernel] and use a linked list
for free blocks, aka **free list**. The question of where to store that list
arises. For maximum flexibility, as the number of nodes may not be fixed, OSes
often chose to embed the list in the blocks themselves: each block contains an
additional header with metadata and the link. Example:

```C
typedef struct __node_t {
    int size;
    struct __node_t *next; // Could store a magic to check for memory overrides
} node_t;
```

Some implementations like sosÂ [^sos] keep track of allocated blocks as well.

And yes we must account for the header size during allocation.

----------

Hux uses yet another allocator for pages and reserves the top half (4MiB) of
the kernel heap for it:

> It is simpler and more efficient to have a dedicated allocator just for
> giving out page-sized & page-aligned memory chunks (*slab nodes*), one at a
> time.

FIXME why does Hux have `frame_bitmap` and `slab_alloc`? Is it because frame
allocation only being needed for paging, we need an additional
kernel-"internal" allocator?

## Splitting & Coalescing

For the algorithm and implementation, the OSTEP book makes a distinction
between the *mechanisms* (how the list is managed) from *policies* (which
free node to pick up next). For the policy:

> We will adopt the *Next-Fit* allocation policy. See the relative sections in
> the linked OSTEP chapter for how it works and how it compares to
> *First-Fit*. Basically, we maintain a `last_search_node` pointer which points
> to where the last request was served. As a new request comes, we start
> traversing the free-list from that node, until we see a node that is large
> enough for the request. [^hux-kernel]

For the mechanisms, there are 2:

- *Splitting*: when allocating, we may split a chosen node
- *Coalescing*: when freeing, merge the chunk with its neighbors.


## References

- [^hux-kernel]: [hux-kernel](https://github.com/josehu07/hux-kernel.wiki/blob/master/11.-Heap-Memory-Allocator.md)
- [^sos]: [sos](sos.enix.org/)
