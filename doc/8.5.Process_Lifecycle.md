# 8.5 Process lifecycle

## Syscall API

One thing we need to tidy up is our syscall API. We want a few things:

1. be able to pass arguments to system calls. We will adopt the [C calling
   convention](https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-system-calls):
   syscall number in EAX, arguments on the stack, with EIP first:

    > it is assumed the program will call a function that issues int 80h […]

1. a user interface to expose syscalls. TODO

## XXX

What naturally comes next is being able to let our first program complete:
return to the user mode execution after the system call and let the process
return or exit.


Having covered the whole lifecycle of a process, we can now come back to the
scheduler and look at the unusual hanlding of the process table lock: in the
scheduler loop, we acquire it to find a runnable process, but we run the
process immediately, instead of releasing the lock. From xv6's code:

```C
      // […] It is the process's job
      // to release ptable.lock and then reacquire it
      // before jumping back to us
```

Actually the lock is released right at the beginning of the process in
`process_entry()`. It's reacquired later in `exit()`.

> xv6 holds `ptable.lock` across calls to swtch: the caller of `swtch` must
> already hold the lock, and control of the lock passes to the switched-to
> code. This convention is unusual with locks; usually the thread that acquires
> a lock is also responsible for releasing the lock, which makes it easier to
> reason about correctness. For context switching it is necessary to break this
> convention because `ptable.lock` protects invariants on the process’s `state`
> and `context` fields that are not true while executing in `swtch`. One
> example of a problem that could arise if `ptable.lock` were not held during
> `swtch`: a different CPU might decide to run the process after `yield` had
> set its state to RUNNABLE, but before `swtch` caused it to stop using its own
> kernel stack. The result would be two CPUs running on the same stack, which
> cannot be right.

FIXME not sure to understand this ^^^ 100%. What would happened if we'd release
the lock right after finding a `READY` process?
